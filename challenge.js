// Bruce force - Simple and exhaustive technique that evaluates every possible outcome to find the best solution. Example: Linear search

// Greedy - Choose the best option at the current time, without any consideration for the future. Example: Dijkstras algorithm, Prims algorithm and Kruskals algorithm

// Divide and Conquer - Divide the problem into smaller sub-problems. Each sub-problem is then solved and the partial solutions are recombined to determine the overaall
// solution. Example : Binary Search, Quick Sort, Merge Sort and Tower of Hanoi.

// Dynamic Programming - Divide the problem into smaller sub-problems. Break it down into smaller but overlapping sub problems. Store the result and reuse
// it for the same sub-problems. This is called memoization and is a optimization technique that improves the time complexity of your algorithm. Example Fibinacci numbers and climbing staircase.

// Backtracking - Generate all possible solutions. Check if the solution satifies all the given constrians and only then you proceed with generating
// subsequent solutions. If the constraints are not satisfied, backtrack and go on a different path to find the solutiuon. Example: N-Queens problem.

// NEXT STEPS

Solve more problems
  - Finding the GCD using Euclidian algorithm
  - Finding permutations and combinations of a list of numbers
  - Finding the longest common substring in a given string
  - Knapsack problem
